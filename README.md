# study_scala
스칼라 : 누구나 쉽게 스칼라 + 플레이

##[요약정리]Scala에 대하여

<ol style="list-style-type: decimal;"><li>스칼라는 모든것이 객체이다.</li><li>Object는 싱클턴 객체이다.</li><li>스칼라 Objec = 자바의 static class</li><li>static예약어가 필요없다.</li><li>+와 같은 연산자도 객체이다.</li><li>스칼라의 Unit = 자바의 void</li><li>세미콜론을 쓰지 않아도 된다.</li><li>자료형은 컴파일러가 알아서 정해준다.<br />var : 일반적인 변수(값 변경 가능)<br />val : final 변수(값 변경 불가, immutalbe)</li><li>변수 선언시 빈 값은 null 보다 None을 권장</li><li>변수 자료형 선언방법<br />변수명 뒤에 :(콜론)과 함께 쓴다.<br />var num : Int = 10</li><li>val, var의 생략 불가</li><li>기본 자료형 AnyVal<br /></li><li>참조 자료형 AnyRef</li><li>if문은 자바와 같다.</li><li>for문에서 to는 until로 바꿔 쓸 수 있다.<br />to는 ~ 까지<br />until은 ~미만<br />until보다 to가 한 루프 더 돈다.</li><li>--(1감소), ++(1증가)&nbsp;표현을 지원하지 않는다.</li><li>while문 do while문도 자바와 같다.&nbsp;</li><li>class의 구현부를 없앨 수 있다.</li><li>case class는 class의 확장형으로 외부에서 멤버변수에 접근이 가능하다.<br />case class는 new 생략가능</li><li>동반객체<br />같은 이름의 객체와 클래스<br />각자의 private 필드나 메서드를 자유롭게 접근할 수 있다.</li><li>상속<br />부모 이기는 자식 없다.</li><li>트레이트(trait) = 특성<br />트레이트 : &nbsp;하나의 완성된 기능이라기 보다는 어떠한 객체에 추가될 수 있는 부가적인 하나의 특성<br />트레이트와 추상클래스는 그자체로 인스턴스화가 어렵다.<br />트레이트에서 구현된 메서드를 오버라이드 하고 싶을때&nbsp;override 예약어를 꼭 써야한다.<br />트레이트의 기능을 보면 다중상속을 제외하고는 추상메서드와 다를게 없고, 로직을 구현할 수 있다는 점을 제외한다면 인터페이스와 다를게 없다.</li><li>다이아몬상속이 가능함<br />마지막 override만 실행 할 수도 있고, 전부 다 실행 할수도 있다.</li><li>예약어 return 생략가능<br />return 명시하면 리턴 타입 필수</li><li>리턴타입 생략가능<br />예약어 return 생략 불가<br /></li><li>'=&gt;' call by name <br />'=&gt;'를 함수 표현식이라고 한다.<br />매개변수가 필요할 때 해당 함수를 실행시켜 값을 가져온다.<br />함수를 실행 시켜 리턴 값만 가져오는 것이 아니라 함수 자체를 부른 다는 것이다.</li><li>매개변수에 함수를 넣을 수 있다.</li><li>부분함수<br />함수의 일부 매개변수만 고정하는 것이다.<br />계속 변하는 매개변수는 '_'로 쓰고 자료형만 정해주면 된다.</li><li>커링<br />여러 개의 인수를 받는 하나의 함수를 하나의 인수를 받는 여러개의 함수로 바꿔주는 기법<br />매개변수를 받을 때 각각의 매개변수를 ()로 감싸준다.</li><li>스칼라는 매개변수가 하나면 Function1, 두 개면 Function2, 이런식으로 22개 까지 Function을 상속하는 트레이트를 제공한다.</li><li>스칼라는 함수 자체를 1급 시민으로 다룬다.<br />1급 시민 혹은 1급 객체란 매개변수의 인수로 들어갈 수도 있고 반환으로 받을 수도 있는&nbsp;자격을 가진 객체를 말한다.</li><li>loop함수 - &nbsp;반복문</li><li>함수내부에서 자신을 다시 호출 하는 함수를 재귀함수라고 한다.</li><li>매개 변수의 기본값을 정해 줄 수 있다.</li><li>apply()는 변수를 받아 함수에 적용시켜 결과를 만들어내는 일종의 설정자와 같은 역할을 한다.<br />인스턴스를 부르면 바로 apply()가 실행된다.<br />자바의 생성자 역할도 한다.&nbsp;</li><li>implicit함수<br />암묵적인, 묵시적이라는 뜻으로 적당한 함수가 있으면 연결해서 에러를 줄인다.</li><li>함수는 메서드를 아우르는 용어다.<br /></li><li>Any 아무 자료형이나 가능</li><li>case class<br />패턴매칭에 적합한 클래스<br />보통의 클래스보다 기능이 많다.</li><li>Extractor 패턴 매칭<br />Extractor : 추출자<br />unapply() : 추출함수<br /></li><li>한 배열안에 서로다른 타입의 자료형을 동시에 넣을 수 있다.</li><li>데이터의 집합을 벡터라고 한다.<br />벡터들이 모여있는 형태는 행렬이라고 한다.<br />행렬은 데이터가 횡과 종으로 모여있는 상태를 말한다.</li><li>리스트는 초기화시 크기를 지정하지 않아도 된다.<br />크기가 동적이다.<br />리스트는 생성시 new를 쓰지 않는다.<br />cons("::")연산자를 통해 리스트에 속한 데이터임을 표기 한다.<br />마지막에 Nil을 필수로 붙여줘야 한다.<br />Nil은 리스트의 끝을 의미한다.<br />&nbsp;ex) val list = "a" :: "b" :: "c" :: "d" Nil<br />빈리스트를 생성하고 싶으면 Nil을 초기화 하면 된다.<br />"++"나 ":::"연산자로 리스트를 합칠 수 있다.</li><li>map은 java와 거의 비슷하다.<br />맵 생성시&nbsp;new를 쓰지 않는다.<br />자료형을 명시 하지 않아도 된다. (제네릭하게 사용됨)<br />맵에 데이터를 추가할 때는 "+"연산자를 사용한다.<br />맵에 데이터를 삭제할 때는 "-"연산자를 사용한다.<br /></li><li>set(집합)은 중복을 허용하지 않는다.</li><li>튜플(Tuple) 데이터의 묶음이다.<br />괄호와 쉼표를 통해 생성한다.<br />튜플은 함수를 통해 반환 될때&nbsp;하나의 값으로&nbsp;본다.</li><li>옵션은 None이거나 Some()을 하나이상 가지고 있다.<br />None은 널 포인터 예외를 방지해준다.</li></ol><p><br /></p>
